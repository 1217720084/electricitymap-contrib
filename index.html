<!DOCTYPE html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF8">
    <style>
        html, body {    
            margin: 0 !important;
            padding: 0 !important;
            height: 100%;
        }
        .land {
            fill: #ccc;
            fill-opacity: 0.8;
            stroke: #3b3b3b;
        }
        .sea {
            background-color: white;
        }
        .map {
            width: 100%;
            height: 100%;
        }
        .graticule {
            stroke: #185c96;
            stroke-width: 0.3px;
        }
        .panel-container {
            position: absolute;
            top: 0px;
            margin: 10px;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid grey;
        }
    </style>
    </head>
<body>
    
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/d3.geo.projection.v0.min.js"></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>
    <script src="http://d3js.org/topojson.v0.min.js"></script>
    
    <!-- <script src="d3.v3.min.js"></script>
    <script src="d3.geo.projection.v0.min.js"></script>
    <script src="queue.v1.min.js"></script>
    <script src="topojson.v0.min.js"></script> -->
    
    <svg class="map"></svg>
    <div class="panel-container">
        <svg class="panel"></svg>
    </div>
    <script>
        // Global state
        // TODO: Use redux?
        var state = {
            'selectedCountry': null
        }

        var panelHeight = '300px',
            panelWidth = '360px',
            panelPadding = 10;

        var productionBarHeight = 8,
            productionBarMaxWidth = 120;
            productionBarMarginY = 10;

        var productionColors = {
            'wind': '#74cdb9',
            'solar': '#f27406',
            'hydro': '#2772b2',
            'biomass': '#166a57',
            'coal': '#ac8c35',
            'oil': '#8356a2',
            'nuclear': '#f5b300',
            'gas': '#f30a0a',
            'other': 'gray'
        };
        var productionModes = d3.keys(productionColors);

        // Scales
        var co2color = d3.scale.linear()
            .domain([0, 250, 500])
            .range(['green', 'orange', 'black']);

        var productionScale = d3.scale.linear()
            .range([0, productionBarMaxWidth]);

        var exchangeAnimationScale = d3.scale.linear()
            .domain([500, 4000])
            .range([2000, 10])
        var exchangeArrowWidthScale = d3.scale.linear()
            .domain([500, 4000])
            .range([4, 15])

        var map = d3.select('.map')
            .attr('class', 'map sea');

        var graticule = map.append('path').attr('class', 'graticule');
        var land = map.append('g');
        var panel = d3.select('.panel')

        var productionRects = {};
        var capacityRects = {};
        var productionPrefixText = {};
        var productionSuffixText = {}
        var prefixTextMaxWidth = 80;
        productionModes.forEach(function (mode, i) {
            capacityRects[mode] = panel.append('rect')
                .attr('height', productionBarHeight)
                .attr('fill', 'none') // TODO: Replace by css?
                .attr('stroke', productionColors[mode])
                .attr('stroke-width', 0.5)
                .attr('y', panelPadding + i * (productionBarMarginY + productionBarHeight))
                .attr('x', panelPadding + prefixTextMaxWidth)
            productionRects[mode] = panel.append('rect')
                .attr('height', productionBarHeight)
                .attr('fill', productionColors[mode])
                .attr('y', panelPadding + i * (productionBarMarginY + productionBarHeight))
                .attr('x', panelPadding + prefixTextMaxWidth)
            productionPrefixText[mode] = panel.append('text')
                .attr('font-size', 12)
                .attr('x', panelPadding)
                .attr('y', panelPadding + 6 + i * (productionBarMarginY + productionBarHeight)); // TODO: Do it with CSS and the em or rem unit measure
            productionSuffixText[mode] = panel.append('text')
                .attr('font-size', 12)
                .attr('x', panelPadding + 8 + prefixTextMaxWidth + productionBarMaxWidth)
                .attr('y', panelPadding + 6 + i * (productionBarMarginY + productionBarHeight))
        });

        // Prepare exchanges
        let exchangeArrowsContainer = map.append('g')
        let exchangeGradientsContainer = map.append('g')

        const TRIANGLE_HEIGHT = 8;
        function trianglePath(w) {
            return 'M 0 0 L ' + w + ' ' + TRIANGLE_HEIGHT + ' L -' + w + ' ' + TRIANGLE_HEIGHT + ' Z ' +
            'M 0 -' + TRIANGLE_HEIGHT + ' L ' + w + ' 0 L -' + w + ' 0 Z ' +
            'M 0 -' + TRIANGLE_HEIGHT * 2.0 + ' L ' + w + ' -' + TRIANGLE_HEIGHT + ' L -' + w + ' -' + TRIANGLE_HEIGHT + ' Z'
        };

        function animateGradient(selector, color, duration) {
            var arrow = selector.selectAll('stop')
                .data([
                    {offset: 0, color: 'black'},
                    {offset: 0, color: 'black'},
                    {offset: 0, color: color},
                    {offset: 0, color: 'black'},
                    {offset: 1, color: 'black'},
                ]);
            arrow.enter().append('stop')
                .attr('offset', function(d) { return d.offset; })
                .attr('stop-color', function(d) { return d.color; })
            arrow
                .transition()
                .duration(duration)
                .ease('linear')
                .attrTween('offset', function(d, i, a) {
                    // Only animate the middle color
                    if (i == 0 || i == 4)
                        return function (t) { return d.offset };
                    else {
                        return function (t) { return 1 - t + (i - 2) * 0.4 };
                    }
                })
                .each('end', function () { 
                    return animateGradient(selector, color, duration);
                });
        };

        function redraw() {
                
            var computedMapWidth = d3.select('.map').node().getBoundingClientRect().width,
                computedMapHeight = d3.select('.map').node().getBoundingClientRect().height;

            var projection = d3.geo.mercator()
                .center([3, 48])
                .translate([0.6 * computedMapWidth, 0.6 * computedMapHeight])
                .scale(700);
                
            var path = d3.geo.path()
                .projection(projection);
                
            var graticuleData = d3.geo.graticule()
                .step([5, 5]);
                
            graticule
                .datum(graticuleData)
                .attr('d', path);

            panel
                .attr('width', panelWidth)
                .attr('height', panelHeight);

            let cb = function(err, data, realtime) {

                let topo = topojson.object(data, data.objects.europe).geometries;

                var countries = {};
                countries['BE'] = topo[4];
                countries['CH'] = topo[8];
                countries['DE'] = topo[10];
                countries['DK'] = topo[11];
                countries['ES'] = topo[12];
                countries['FI'] = topo[14];
                countries['FR'] = topo[15];
                countries['UK'] = topo[17];
                countries['IE'] = topo[24];
                countries['IT'] = topo[26];
                countries['LU'] = topo[31];
                countries['NL'] = topo[38];
                countries['NO'] = topo[39];
                countries['PT'] = topo[41];
                countries['SE'] = topo[48];

                // Add empty fields
                for (let countryCode of d3.keys(countries)) {
                    countries[countryCode].meta = {};
                    countries[countryCode].meta.capacity = {}
                }

                countries['DE'].meta.capacity = {
                    solar: 39700,
                    wind: 2700 + 40990,
                    gas: 28540,
                    hydro: 5580,
                    biomass: 8860,
                    nuclear: 10790,
                    coal: 27090 + 21140
                };
                countries['DK'].meta.capacity = {
                    wind: 5070,
                    solar: 790,
                    hydro: 0,
                };
                countries['FR'].meta.capacity = {
                    nuclear: 63130,
                    oil: 6670,
                    coal: 2930,
                    hydro: 10326 + 8204 + 4965,
                    gas: 6121,
                    wind: 1426 + 10,
                    solar: 5200
                };
                countries['UK'].meta.capacity = {
                    wind: 13500,
                    nuclear: 9000,
                    hydro: 1550,
                    gas: 38000
                }

                // Prepare exchanges
                let exchanges = [
                    {
                        countries: ['DE', 'DK'],
                        center: projection([9.3, 54.9]), 
                        rotation: 0
                    },
                    {
                        countries: ['SE', 'DK'],
                        center: projection([13, 55.7]), 
                        rotation: -100
                    },
                    {
                        countries: ['UK', 'FR'],
                        center: projection([0, 50.4]), 
                        rotation: 160
                    },
                    {
                        countries: ['DK', 'NO'],
                        center: projection([8.8, 58]), 
                        rotation: -25
                    },
                    {
                        countries: ['IE', 'UK'],
                        center: projection([-5.7, 53]), 
                        rotation: 100
                    },
                    {
                        countries: ['NL', 'UK'],
                        center: projection([3.3, 52.4]), 
                        rotation: -90
                    },
                    {
                        countries: ['FR', 'ES'],
                        center: projection([0.3, 42.9]), 
                        rotation: -160
                    },
                    {
                        countries: ['FR', 'DE'],
                        center: projection([5.7, 49.8]), 
                        rotation: 50
                    },
                    {
                        countries: ['FR', 'CH'],
                        center: projection([6.5, 46.7]), 
                        rotation: 90
                    },
                    {
                        countries: ['FR', 'IT'],
                        center: projection([6.5, 44.5]), 
                        rotation: 70
                    }
                ];

                // Populate with realtime data
                for (let countryCode of d3.keys(realtime.data)) {
                    let obj = realtime.data[countryCode];
                    let country = countries[countryCode]
                    for (let k of d3.keys(obj))
                        country.meta[k] = obj[k];
                    // Add extra data
                    // TODO: Calculate co2 in the browser to take into account exchanges
                    country.meta.maxCapacity = 
                        d3.max(d3.values(country.meta.capacity));
                    country.meta.maxProduction = 
                        d3.max(d3.values(country.meta.production));
                    country.meta.totalProduction = 
                        d3.sum(d3.values(country.meta.production));
                    // Populate exchanges
                    // Very hacky as the last country will always have precedence
                    for (let sourceCountryCode of d3.keys(country.meta.exchange)) {
                        // Find the exchange object
                        var matches = exchanges.filter(function (e) { 
                            return (e.countries[0] == countryCode && e.countries[1] == sourceCountryCode) || (e.countries[1] == countryCode && e.countries[0] == sourceCountryCode)
                        });
                        var amount = country.meta.exchange[sourceCountryCode];
                        if (matches.length) {
                            var match = matches[0];
                            match.netFlow = match.countries[0] == sourceCountryCode ? amount : -amount;
                        } else {
                            if (sourceCountryCode != 'other')
                                console.warn('Missing exchange configuration between ' + sourceCountryCode + ' and ' + countryCode);
                        }
                    }
                    // Send warnings for missing data
                    if (country.meta.co2 === undefined)
                        console.warn(countryCode + ' is missing co2 footprint');
                    productionModes.forEach(function (mode) {
                        if (mode == 'other') return;
                        if (country.meta.production[mode] === undefined)
                            console.warn(countryCode + ' is missing production of ' + mode);
                        if (country.meta.capacity[mode] === undefined)
                            console.warn(countryCode + ' is missing capacity of ' + mode);
                    });
                    if (country.meta.exchange === undefined || country.meta.exchange.length == 0)
                        console.warn(countryCode + ' is missing exchanges');
                }
                console.log('countries', countries);
                console.log('exchanges', exchanges);

                var exchangeGradients = exchangeGradientsContainer.selectAll('.exchange-gradient')
                    .data(exchanges)
                    .enter()
                    .append('linearGradient')
                    .attr('gradientUnits', 'userSpaceOnUse')
                    .attr('x1', 0).attr('y1', -2.0 * TRIANGLE_HEIGHT - 5)
                    .attr('x2', 0).attr('y2', TRIANGLE_HEIGHT + 5)
                    .attr('id', function (d, i) { return 'exchange-gradient-' + i; });

                var exchangeArrows = exchangeArrowsContainer.selectAll('.exchange-arrow')
                    .data(exchanges)
                    .enter()
                    .append('path')
                    .attr('class', 'exchange-arrow')
                    .attr('d', function(d) { 
                        return trianglePath(exchangeArrowWidthScale(Math.abs(d.netFlow)));
                    })
                    .attr('transform', function (d) {;
                        let rotation = d.rotation + (d.netFlow < 0 ? 180 : 0);
                        return 'translate(' + d.center[0] + ',' + d.center[1] + '),rotate(' + rotation + ')';
                    })
                    .attr('fill', function (d, i) { return 'url(#exchange-gradient-' + i + ')' })
                    .attr('stroke', function (d) { return d.netFlow ? 'black' : 'none'; })
                    .attr('stroke-width', 0.4)
                    .on('click', function (d) { console.log(d, exchangeAnimationScale(Math.abs(d.netFlow))); })
                    .each(function (d, i) {
                        if (!d.netFlow) return;
                        var co2 = countries[d.countries[d.netFlow > 0 ? 0 : 1]].meta.co2;
                        return animateGradient(
                            d3.select('#exchange-gradient-' + i), 
                            co2 ? co2color(co2) : 'grey',
                            exchangeAnimationScale(Math.abs(d.netFlow))
                        );
                    });

                land.selectAll('.country')
                    .data(d3.values(countries))
                    .enter()
                        .append('path')
                        .attr('class', 'country')
                        .attr('d', path)
                        .attr('stroke', 'black')
                        .attr('stroke-width', 0.3)
                        .attr('fill', function (d, i) { 
                            return d.meta.co2 ? co2color(d.meta.co2) : 'gray';
                        })
                        .on('mouseover', function (d) { 
                            if (d.meta.production)
                                d3.select(this)
                                    .attr('opacity', 0.7)
                                    .style('cursor', 'hand')
                        })
                        .on('mouseout', function (d) { 
                            if (d.meta.production) 
                                d3.select(this)
                                    .attr('opacity', 1)
                                    .style('cursor', 'normal')
                        })
                        .on('click', function (d, i) { 
                            if (!d.meta.production) return;
                            productionScale.domain([0, d.meta.maxCapacity || d.meta.maxProduction]);
                            productionModes.forEach(function (mode) {
                                productionRects[mode]
                                    .datum(d.meta)
                                    .transition()
                                    .attr('width', function (d, i) {
                                        return productionScale(d.production[mode] || 0)
                                    });
                                capacityRects[mode]
                                    .datum(d.meta)
                                    .transition()
                                    .attr('width', function (d, i) {
                                        return d.production[mode] === undefined ? 0 : productionScale(d.capacity[mode] || 0)
                                    });
                                let production = Math.round(d.meta.production[mode] / 10) * 10
                                if (d.meta.capacity[mode] !== undefined && d.meta.production[mode] !== undefined) {
                                    let capacityPct = Math.round(d.meta.production[mode] / d.meta.capacity[mode] * 100)
                                    productionSuffixText[mode]
                                        .text(production + ' MW (' + capacityPct + '% capacity)')
                                } else if (d.meta.production[mode] !== undefined) {
                                    productionSuffixText[mode].text(production + ' MW');
                                } else {
                                    productionSuffixText[mode].text('')
                                }
                                if (d.meta.production[mode] !== undefined) {
                                    productionPrefixText[mode]
                                        .text(mode + ' (' + Math.round(d.meta.production[mode]/d.meta.totalProduction*100.0) + '%)')
                                } else {
                                    productionPrefixText[mode].text(mode)
                                }
                            });
                        });
            };

            queue()
                .defer(d3.json, 'http://localhost:8000/data/europe.topo.json')
                .defer(d3.json, 'http://localhost:8000/realtime')
                .await(cb);
        };

        // TODO: Put as much as possible in CSS

        window.onresize = function () {
            redraw();
        };

        redraw();
    </script>   
</body>
</html>
