<!DOCTYPE html>
<head>
<style>
    html, body {    
        margin: 0 !important;
        padding: 0 !important;
        height: 100%;
    }
    .land {
        fill: #ccc;
        fill-opacity: 0.8;
        stroke: #3b3b3b;
        stroke-width: 0.3px;
    }
    .sea {
        background-color: white;
    }
    .map {
        width: 100%;
        height: 100%;
    }
    .graticule {
        stroke: #185c96;
        stroke-width: 0.3px;
    }
    .panel-container {
        position: absolute;
        top: 0px;
        margin: 10px;
        background-color: rgba(255, 255, 255, 0.95);
        border: 1px solid grey;
    }
</style>
</head>
<body>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/d3.geo.projection.v0.min.js"></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>
    <script src="http://d3js.org/topojson.v0.min.js"></script>
    <svg class="map"></svg>
    <div class="panel-container">
        <svg class="panel"></svg>
    </div>
    <script>
        // Global state
        // TODO: Use redux?
        var state = {
            'selectedCountry': null
        }

        var panelHeight = '300px',
            panelWidth = '360px',
            panelPadding = 10;

        var productionBarHeight = 8,
            productionBarMaxWidth = 120;
            productionBarMarginY = 10;

        var productionColors = {
            'wind': '#74cdb9',
            'solar': '#f27406',
            'hydro': '#2772b2',
            'biomass': '#166a57',
            'coal': '#ac8c35',
            'oil': '#8356a2',
            'nuclear': '#f5b300',
            'gas': '#f30a0a',
            'other': 'gray'
        };
        var productionModes = d3.keys(productionColors);

        // Scales
        var co2scale = d3.scale.linear()
            .domain([0, 250, 500])
            .range(['green', 'orange', 'black']);

        var productionScale = d3.scale.linear()
            .range([0, productionBarMaxWidth]);

        var drawMap = function()  {
                
            // Set up map
            var computedMapWidth = d3.select('.map').node().getBoundingClientRect().width,
                computedMapHeight = d3.select('.map').node().getBoundingClientRect().height;

            var projection = d3.geo.mercator()
                .center([3, 48])
                .translate([0.6 * computedMapWidth, 0.6 * computedMapHeight])
                .scale(700);
                
            var path = d3.geo.path()
                .projection(projection);
                
            var graticule = d3.geo.graticule()
                .step([5, 5]);
                
            var map = d3.select('.map')
                .attr('class', 'map sea');
                
            map.append('path')
                .datum(graticule)
                .attr('class', 'graticule')
                .attr('d', path);
                
            var land = map.append('g');

            var panel = d3.select('.panel')
                .attr('width', panelWidth)
                .attr('height', panelHeight);

            var productionRects = {};
            var capacityRects = {};
            var productionPrefixText = {};
            var productionSuffixText = {}
            var prefixTextMaxWidth = 80;
            productionModes.forEach(function (mode, i) {
                capacityRects[mode] = panel.append('rect')
                    .attr('height', productionBarHeight)
                    .attr('fill', 'none') // TODO: Replace by css?
                    .attr('stroke', productionColors[mode])
                    .attr('stroke-width', 0.2)
                    .attr('y', panelPadding + i * (productionBarMarginY + productionBarHeight))
                    .attr('x', panelPadding + prefixTextMaxWidth)
                productionRects[mode] = panel.append('rect')
                    .attr('height', productionBarHeight)
                    .attr('fill', productionColors[mode])
                    .attr('y', panelPadding + i * (productionBarMarginY + productionBarHeight))
                    .attr('x', panelPadding + prefixTextMaxWidth)
                productionPrefixText[mode] = panel.append('text')
                    .attr('font-size', 12)
                    .attr('x', panelPadding)
                    .attr('y', panelPadding + 6 + i * (productionBarMarginY + productionBarHeight)); // TODO: Do it with CSS and the em or rem unit measure
                productionSuffixText[mode] = panel.append('text')
                    .attr('font-size', 12)
                    .attr('x', panelPadding + 8 + prefixTextMaxWidth + productionBarMaxWidth)
                    .attr('y', panelPadding + 6 + i * (productionBarMarginY + productionBarHeight))
            });

            let cb = function(err, data, realtime) {

                let topo = topojson.object(data, data.objects.europe).geometries;

                var countries = {};
                countries['BE'] = topo[4];
                countries['CH'] = topo[8];
                countries['DE'] = topo[10];
                countries['DK'] = topo[11];
                countries['ES'] = topo[12];
                countries['FR'] = topo[15];
                countries['UK'] = topo[17];
                countries['SE'] = topo[48];

                // Add empty fields
                for (let countryCode of d3.keys(countries)) {
                    countries[countryCode].meta = {};
                    countries[countryCode].meta.capacity = {}
                }

                countries['DE'].meta.capacity = {
                    solar: 39700,
                    wind: 2700 + 40990,
                    gas: 28540,
                    hydro: 5580,
                    biomass: 8860,
                    nuclear: 10790,
                    coal: 27090 + 21140
                };
                countries['DK'].meta.capacity = {
                    wind: 5070,
                    solar: 790,   
                };
                countries['FR'].meta.capacity = {
                    nuclear: 63130,
                    oil: 6670,
                    coal: 2930,
                    hydro: 10326 + 8204 + 4965,
                    gas: 6121,
                    wind: 1426 + 10,
                    solar: 396.6
                };
                countries['UK'].meta.capacity = {
                    wind: 13500,
                    nuclear: 9000,
                    solar: 9200,
                    hydro: 1550,
                    gas: 38000
                }

                // Populate with realtime data
                for (let countryCode of d3.keys(realtime.data)) {
                    let obj = realtime.data[countryCode];
                    for (let k of d3.keys(obj))
                        countries[countryCode].meta[k] = obj[k];
                    // Add extra data
                    // TODO: Calculate co2 in the browser
                    countries[countryCode].meta.maxCapacity = 
                        d3.max(d3.values(countries[countryCode].meta.capacity));
                    countries[countryCode].meta.maxProduction = 
                        d3.max(d3.values(countries[countryCode].meta.production));
                    countries[countryCode].meta.totalProduction = 
                        d3.sum(d3.values(countries[countryCode].meta.production));
                }
                console.log(countries);

                let exchange_dk_de = exchanges.append('path')
                .attr('d', function(d) { 
                  return 'M 0 0 L 10 10 L -10 10 Z M 0 -10 L 10 0 L -10 0 Z M 0 -20 L 10 -10 L -10 -10 Z';
                })
                .datum(exchangesConfig[0])
                .attr('transform', function (d) {
                    let netFlow = countries[d.countries[1]].meta.import[d.countries[0]];
                    let rotation = d.rotation + (netFlow < 0 ? 180 : 0);
                    return 'translate(' + d.center[0] + ',' + d.center[1] + '),rotate(' + rotation + ')';
                })

                land.selectAll('.country')
                    .data(d3.values(countries))
                    .enter()
                        .append('path')
                        .attr('class', 'country')
                        .attr('d', path)
                        .attr('stroke', 'black')
                        .attr('stroke-width', 0.2)
                        .attr('fill', function (d, i) { 
                            return d.meta.co2 ? co2scale(d.meta.co2) : 'gray';
                        })
                        .on('click', function (d, i) { 
                            if (!d.meta) return;
                            productionScale.domain([0, d.meta.maxCapacity || d.meta.maxProduction]);
                            productionModes.forEach(function (mode) {
                                productionRects[mode]
                                    .datum(d.meta)
                                    .transition()
                                    .attr('width', function (d, i) {
                                        return productionScale(d.production[mode])
                                    });
                                capacityRects[mode]
                                    .datum(d.meta)
                                    .transition()
                                    .attr('width', function (d, i) {
                                        return productionScale(d.capacity[mode])
                                    });
                                let production = Math.round(d.meta.production[mode] / 100) * 100
                                if (d.meta.capacity[mode] && d.meta.production[mode]) {
                                    let capacityPct = Math.round(d.meta.production[mode] / d.meta.capacity[mode] * 100)
                                    productionSuffixText[mode]
                                        .text(production + ' MW (' + capacityPct + '% capacity)')
                                } else if (d.meta.production[mode]) {
                                    productionSuffixText[mode].text(production + ' MW');
                                } else {
                                    productionSuffixText[mode].text('')
                                }
                                if (d.meta.production[mode]) {
                                    productionPrefixText[mode]
                                        .text(mode + ' (' + Math.round(d.meta.production[mode]/d.meta.totalProduction*100.0) + '%)')
                                } else {
                                    productionPrefixText[mode].text(mode)
                                }
                            });
                        });
            };

            // Draw import/exports
            let exchangesConfig = [
                {
                    center: projection([10, 54.7]), 
                    rotation: 10,
                    countries: ['DE', 'DK']
                }
            ];

            let exchanges = map.append('g')
                .attr('class', 'exchanges')
            

            queue()
                .defer(d3.json, 'http://localhost:8000/data/europe.topo.json')
                .defer(d3.json, 'http://localhost:8000/realtime')
                .await(cb);
        };

        // TODO: Put as much as possible in CSS

        window.onresize = function () {
            console.log('resize');
            // TODO: Bind
        };

        drawMap();
    </script>   
</body>
</html>
